---
title: 快速排序
date: 2016-12-07 09:12:16
tags: Java
category: 算法
---
快速排序可能是目前应用最广的排序算法。快速排序流行的原因是它试用各种不同的输入，而且在一般应用中比其它排序算法都要快。快速排序的优点是:
- 需要很小的辅助栈
- 长度为N的数组需要时间和NlgN成正比
- 内循环较小

<!--more-->

## 快速排序思想
我们知道，一个递增的有序数组，任意元素的左边元素不会大于当前元素，任意元素的右边元素不会小于当前元素。举例来说：
有序不重复数组a=[1,2,3,4,5,6,7,8,9]，随意挑选元素4,4大于任意一个在其前面的元素(1,2,3)，小于其后面的任意一个元素(5,6,7,8)。
如果数组a顺序被打乱a=[2, 3, 4, 1, 9, 7, 6, 5, 8],我们只要将4这个元素放到a[3]这个位置即可，对于4这个元素，他就排序好了。
我们如何知道4会在a[3]这个位置呢？我们知道把数组中所有小于４的元素都放到4元素的前面，那么４自然会落在a[3]这个位置。
```java
public static void sort(int[] array, int start, int end) {
    if (start >= end) return;
    int j = partition(array, start, end);
    sort(array, start, j - 1);
    sort(array, j + 1, end);
}
```
每一次调用sort,partition方法都会将a[j]排好序，递归下去，我么就能将所有元素排序，一个好的切分方法是决定快速排序性能的关键。

## 切分方法
```java
public static int partition(int[] array, int start, int end) {
    int lo = start;
    int hi = end + 1;
    while (true) {
        while (array[++lo] < array[start]) if (lo == end) break;
        while (array[--hi] > array[start]) if (hi == start) break;
        if (lo >= hi) break;
        exch(array, hi, lo);
    }
    exch(array, start, hi);
    return hi;
}
```
上面代码值得考究的是：
1. hi为什么要为end+1
2. while循环内的大于和小于关系
3. 当while循环跳出时，为什么要和hi交换
4. 当while循环跳出时，lo和hi最多相差多少
5. `if (lo == end) break;`和`if (hi == start) break;`是不是必须的

## 快速排序的问题
上述代码只是一个快速排序代码的一个简单实现，大部分情况下表现也还不错，不过还是有一些问题。

上述代码的性能在于如何切分数组，对于数组[9,8,7,6,5,4,3,2,1]排序，时间复杂度也是n2级别的，因为每次切割数组分割的极度不均匀，最理想的情况下是每次挑选的元素都是数组中的中位数，这样可以等分切割数组(上面的代码是排序数组的第一个元素)，一般可以在排序前先打乱数组，防止出现切分极度不平衡的情况(最糟糕的情况)，快速排序是一种偏爱随机性的排序算法。

在有大量的重复元素的情况下，例如全部重复的数组，我们的代码会继续将它切分，递归。复杂度从对数级别到线性对数级别，我们通过一些复杂的的方法处理这种情况，此处不在讨论。
