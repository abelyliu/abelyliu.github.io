---
title: 自底向上的并归排序
date: 2016-12-06 10:17:27
tags: Java
category: 算法
---
前面我们曾经讨论过自顶向下的并归排序，其主要思路是将一个大的数组递归分解成小的数组，而自底向上的并归排序则是递归合并小数组，然后变成一个有序的大数组，如果数组长度为２的幂时，两种方法比较次数和数组访问次数都相同，只不过顺序不同。如果对并归排序不该熟悉，可以先看上一篇文章。
<!--more-->

这两种排序的方法，合并的代码是相同的,不再解释：
```java
public static void merge(int start, int mid, int end, int[] array) {
    int m = start;
    int n = mid + 1;
    int[] temp = new int[end + 1];
    for (int i = start; i <= end; i++) {
        temp[i] = array[i];
    }
    for (int i = start; i <= end; i++) {
        if (m > mid) array[i] = temp[n++];
        else if (n > end) array[i] = temp[m++];
        else if (temp[m] > temp[n]) array[i] = temp[n++];
        else array[i] = temp[m++];
    }
}
```

排序代码如下：
```java
public static void sort(int[] array){
   for(int size =1 ;size<array.length;size=size*2){
       for(int i=0;i<array.length-size;i+=size+size){
           merge(i,i+size-1,Math.min(i+size+size-1,array.length-1),array);
       }
   }
}
```
比如我们要排序`{9, 8, 7, 6, 5, 4, 3, 2, 1}`
外层循环代表着分组的大小，int size =1 代表我们要合并[9][8],[7][6],[5][4],[3][2],[1],下一次循环size=2 时我们要合并[8,9][6,7],[4,5][3,2],[1]，循环下去。
内层循环是将数组所有的分组都进行排序。

对于代码来说，如果能理解Math.min(i+size+size-1,array.length-1)，也差不多明白自底向上并归的思路了。

完整代码如下：
```java
public class Test {

    public static void main(String[] args) {
        int[] array = {9, 8, 7, 6, 5, 4, 3, 2, 1};
        sort(array);
        for (int i : array) {
            System.out.print(i + " ");
        }
    }

    public static void sort(int[] array){
        for(int size =1 ;size<array.length;size=size*2){
            for(int i=0;i<array.length-size;i+=size+size){
                merge(i,i+size-1,Math.min(i+size+size-1,array.length-1),array);
            }
        }
    }

    public static void merge(int start, int mid, int end, int[] array) {
        int m = start;
        int n = mid + 1;
        int[] temp = new int[end + 1];
        for (int i = start; i <= end; i++) {
            temp[i] = array[i];
        }
        for (int i = start; i <= end; i++) {
            if (m > mid) array[i] = temp[n++];
            else if (n > end) array[i] = temp[m++];
            else if (temp[m] > temp[n]) array[i] = temp[n++];
            else array[i] = temp[m++];
        }
    }

}
```
