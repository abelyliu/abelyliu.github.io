---
title: 浮点数的表示
date: 2019-06-03 00:21:00
tags: 其他
category: 操作系统
---

我们都知道整数在计算机内是用补码表示的，不知道你有没有考虑过计算机是如何表示一个浮点数的呢？

如果让你设计一个浮点数表示，你又该如何设计呢？

## 定点表示法
有一种比较常见的思想是定点表示法，假设我们浮点数范围定义为0~100内，支持两位精度，这样一共会有10001个数，我们只需要对这10001个数挨个编码即可。定点表示法的核心就是确定小数点的位置，即确定精度。

举一个具体一点的例子，假设我们设计为4个字节，共计32bit，我们一个首位为符号位置，剩下31位如果全表示整数，则就是java中的int。如果我们假定30位为整数位，剩下一位为小数位，则支持精度为0.5，如果29个整数位，2个小数位，则精度为0.25。

我们可以看到，定点表示法是我们事先约定多少位表示小数，多少位表示整数。我们可以看到，小数位越多，精度越高，表示的范围则越小，小数位越少，精度越低，表示的范围越大。定点表示一般会结合具体的业务场景具体设计。

## 浮点表示法
现在我们来介绍一下IEEE 754表示法，java里的浮点数就是用了这种表示方法。

```mathjax!
$$Value = (-1)^s * 2^E * M  $$
```
如果你对科学计数法还有印象，对上面的算式应该不会陌生，s需要一位即可表示正负，只需要很少位表示E，就可以表示很大的一个数，M的值则会决定整个数值的精度。这样就在精度和大小中做了一个折中。
 
 java中float是4个字节，32bit，1个bit符号位(s)，23个小数位(M)，8个bit指数位(E)，。
 
 不知道你有没有想到一个问题，假设我们要表示0.5，我们带入上面公式：
 s=0，M=0.5，E=0
 s=0, M=0.25, E =1
 s=0,M=1,E=-1
 ....
 我们会发现，同一个数值可以有多种不同的表示方法。
 
 对此又引入了规格化的浮点数，所谓规格化的浮点数就是1<=M<2，这样同一个数就只会有一个表示。
 
这样0.5的二进制表示就为0 00000000000000000000000 01111111 

我们来解释下，第一个0代表正数，很容易理解。

00000000000000000000000代表1，为什么00000000000000000000000会代表1呢？我们上面讲到规格化表示M是在1和2之间，所以我们只需要表示小数点后面的数，前面一定是1。

01111111为什么会是-1呢？我们知道8bit可以表示0~255，这里没有用常规的补码，而是用了无符号数。

1. 如果E=11111111，且M=0，则代表无穷大，符号取决于符号位s
2. 如果E=11111111，且M!=0，则代表NAN(非数值)
3. 如果E=00000000，这个时候M的取值变为0<=M<1，这个是为了表示0(不然无法严格等于0，普通情况M!=0，2^E!=0，所以结果也不会为0)，和接近0的小数。
4. 这个是一般的情况，E从00000001~11111110代表-126到127

这时候我们再看01111111，属于第四种情况，换算得到E=-1。

如果有兴趣可以自行测试其他小数的二进制表示，不过值得注意的是，需要将输出补足到32位
```
System.out.println(Integer.toBinaryString(Float.floatToIntBits(0.5f)));

//output 
//111111000000000000000000000000 注意这只有30位，前面需要补充两个00
```
