---
title: 树的遍历
date:  2017-3-8
tags: 算法
category: 
---
树这种数据结构在工作中应用的非常广泛，如解析xml，数据库索引的实现等等。
对于树来说，一个最基本的操作就是如何遍历里面的数据，这个简单讨论一下二叉树的遍历。

<!--more-->
## 深度遍历
### 递归实现
#### 先序遍历
先序遍历就是先遍历根节点然后遍历左右节点。
```java
    public void preOrderTraversal(TreeNode treeNode) {
        if (treeNode == null) return;
        System.out.print(treeNode.val + " ");
        this.preOrderTraversal(treeNode.left);
        this.preOrderTraversal(treeNode.right);
    }
```
#### 中序遍历
中序遍历就是先遍历左或右节点，然后遍历根节点，然后是另一个节点。
```java
    public void inOrderTraversal(TreeNode treeNode) {
        if (treeNode == null) return;
        this.inOrderTraversal(treeNode.left);
        System.out.print(treeNode.val + " ");
        this.inOrderTraversal(treeNode.right);
    }
```

#### 后序遍历
中序遍历就是先遍历左或右节点，然后是另一个节点，然后遍历根节点。
```java
    public void postOrderTraversal(TreeNode treeNode) {
        if (treeNode == null) return;
        this.postOrderTraversal(treeNode.left);
        this.postOrderTraversal(treeNode.right);
        System.out.print(treeNode.val + " ");
    }
```
### 非递归实现
上面的代码简单明了，但是如果树比较深，容易栈溢出。下面是修改为循环实现，下面的遍历一个比一个复杂，尤其是后序遍历，需要区分当前是左节点还是右节点。
#### 先序遍历
```java
    public void preOrderTraversal(TreeNode treeNode) {
        Stack<TreeNode> treeNodeStack = new Stack<>();
        TreeNode root = treeNode;
        while (root != null) {
            System.out.print(root.val + " ");
            if (root.right != null) treeNodeStack.push(root.right);
            if (root.left != null) {
                root = root.left;
                continue;
            } else {
                if (treeNodeStack.size() == 0) break;
                root = treeNodeStack.pop();
            }
        }
    }
```
#### 中序遍历
```java
    public void inOrderTraversal(TreeNode treeNode) {
        Stack<TreeNode> treeNodeStack = new Stack<>();
        boolean flag = true;
        while (treeNode != null) {
            while (treeNode.left != null && flag) {
                treeNodeStack.push(treeNode);
                treeNode = treeNode.left;
            }
            System.out.print(treeNode.val + " ");
            if (treeNode.right != null) {
                treeNode = treeNode.right;
                flag = true;
            } else {
                if (treeNodeStack.size() == 0) break;
                treeNode = treeNodeStack.pop();
                flag = false;
            }
        }
    }
```
#### 后序遍历
```java
    public void postOrderTraversal(TreeNode treeNode) {
        Stack<TreeNode> treeNodeStack = new Stack<>();
        boolean flag = true;
        while (treeNode != null) {
            while (treeNode.left != null && flag) {
                treeNodeStack.push(treeNode);
                treeNode = treeNode.left;
            }
            if (treeNode.right != null) {
                treeNode = treeNode.right;
                flag = true;
            } else {
                System.out.print(treeNode.val + " ");
                while (!treeNodeStack.empty() && treeNodeStack.peek().right == treeNode) {
                    treeNode = treeNodeStack.pop();
                    System.out.print(treeNode.val + " ");
                }
                if (treeNodeStack.empty()) break;
                treeNode = treeNodeStack.peek();
                flag = false;
            }
        }
    }
```
## 广度遍历
广度优先遍历使用队列而非栈实现遍历。
```java
Queue<TreeNode> queue = new LinkedList<>();
public void layerTraver(TreeNode treeNode) {
	while (treeNode != null) {
		System.out.print(treeNode.val + " ");
		if (treeNode.left != null) queue.add(treeNode.left);
		if (treeNode.right != null) queue.add(treeNode.right);
		treeNode = queue.poll();
	}
}
```