---
title: 二叉查找树
date:  2017-3-9
tags: 算法
category: 
---
二叉查找树（英语：Binary Search Tree），也称二叉搜索树、有序二叉树（英语：ordered binary tree），排序二叉树（英语：sorted binary tree），是指一棵空树或者具有下列性质的二叉树：
1. 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
2. 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
3. 任意节点的左、右子树也分别为二叉查找树；
4. 没有键值相等的节点

<!--more-->
## 插入
向一个二元搜寻树b中插入一个s节点的算法，过程为：
1. 若是空树，则将s所指结点作为根节点插入，否则：
2. 若s->data等于b的根节点的数据域之值，则返回，否则：
3. 若s->data小于b的根节点的数据域之值，则把s所指节点插入到左子树中，否则：
4. 把s所指节点插入到右子树中。（新插入节点是叶子节点）
### 递归
```java
    public void insert(TreeNode treeNode) {
        if (root == null) {
            root = treeNode;
        }
        insert(treeNode, root);
    }

    private void insert(TreeNode treeNode, TreeNode root) {
        if (root.val == treeNode.val) return;
        else if (root.val > treeNode.val) {
            if (root.left != null) insert(treeNode, root.left);
            else root.left = treeNode;
        } else {
            if (root.right != null) insert(treeNode, root.right);
            else root.right = treeNode;
        }
    }
```
### 循环
```java
    public void insert(TreeNode treeNode) {
        TreeNode temp;
        if (root == null) {
            root = treeNode;
            return;
        } else {
            temp = root;
        }
        while (temp != null) {
            if (temp.val == treeNode.val) break;
            if (temp.val > treeNode.val) {
                if (temp.left == null) {
                    temp.left = treeNode;
                    break;
                }
                temp = temp.left;
            } else {
                if (temp.right == null) {
                    temp.right = treeNode;
                    break;
                }
                temp = temp.right;
            }
        }
    }
```

## 查找
在二元搜寻树b中查找x的过程为：

1. 若b是空树，則搜索失败，否则：
2. 若x等于b的根节点的数据域之值，則查找成功；否则：
3. 若x小于b的根节点的数据域之值，則搜索左子树；否则：
4. 查找右子树。

### 递归
```java
    public TreeNode search(int value) {
        return search1(value, root);
    }

    private TreeNode search(int value, TreeNode temp) {
        if (temp == null) return null;
        if (temp.val == value) return temp;
        if (temp.val > value) return search(value, temp.left);
        if (temp.val < value) return search(value, temp.right);
        return null;
    }
```

### 循环
```java
    public TreeNode search(int value) {
        TreeNode temp = root;
        while (temp != null) {
            if (temp.val == value) {
                return temp;
            } else if (temp.val > value) {
                temp = temp.left;
            } else {
                temp = temp.right;
            }
        }
        return null;
    }
```

## 删除
在二叉查找树删去一个结点，分三种情况讨论：
1. 若结点为叶子结点，即PL（左子树）和PR（右子树）均为空树。由于删去叶子结点不破坏整棵树的结构，则只需修改其双亲结点的指针即可。
2. 若结点只有左子树PL或右子树PR，此时只要令PL或PR直接成为其双亲结点的左子树或右子树即可，作此修改也不破坏二叉查找树的特性。
3. 若结点的左子树和右子树均不空。在删去节点之后，为保持其它元素之间的相对位置不变。

关于第三种情况，我们参考下图分析：
![enter description here](http://oh5f80tzy.bkt.clouddn.com/1.png)

1. 如果我们要删除2节点，可以将1直接和4相连，3和1的右节点相连。
2. 我们也可以将3和4直连，然后1变成3的左节点

这里的3和1也都可以是树，如果3和1都是树的话，3要和1的右节点的右节点的右节点一直到一个节点的右节点为空时，3变成这个节点的右节点。第二种方法同理。
```java
 public boolean delete(int value) {
        TreeNode temp = root;
        TreeNode tempFather = root;
        while (temp != null) {
            if (temp.val == value) {
				//叶子节点
                if (temp.left == null && temp.right == null) {
                    if (tempFather.right == temp) tempFather.right = null;
                    else if (tempFather.left == temp) tempFather.left = null;
                    else root = null;
                    return true;
                }
				//左节点为空
                if (temp.left == null && temp.right != null) {
                    boolean isroot = false;
                    if (tempFather.right == temp) tempFather.right = temp.right;
                    else if (tempFather.left == temp) tempFather.left = temp.right;
                    else isroot = true;
                    if (isroot) root = temp.right;
                    return true;
                }
				//右节点为空
                if (temp.left != null && temp.right == null) {
                    boolean isroot = false;
                    if (tempFather.right == temp) tempFather.right = temp.left;
                    else if (tempFather.left == temp) tempFather.left = temp.left;
                    else isroot = true;
                    if (isroot) root = temp.left;
                    return true;
                }
				//左右节点都不为空
                if (temp.left != null && temp.right != null) {
                    boolean isroot = false;
                    if (tempFather.right == temp) tempFather.right = temp.left;
                    else if (tempFather.left == temp) tempFather.left = temp.left;
                    else isroot = true;
                    tempFather = temp.right;
                    temp = temp.left;
                    if (isroot) root = temp;
                    while (temp.right != null) {
                        temp = temp.right;
                    }
                    temp.right = tempFather;
                    return true;
                }

            } else if (temp.val > value) {
                tempFather = temp;
                temp = temp.left;
            } else {
                tempFather = temp;
                temp = temp.right;
            }
        }
        return false;
    }   
```


## 参考链接
1. [二叉查找树 - 维基百科](https://zh.wikipedia.org/zh-cn/二元搜尋樹)


  [1]: http://abely.site/1.png "1"