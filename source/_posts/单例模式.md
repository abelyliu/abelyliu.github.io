---
title: 单例模式
date: 2017-02-16 09:04:39
tags: 设计模式
category: Java
---

单例模式应该是23中模式里比较简单的一种模式，无论其功能用途还是其写法，相对来说都比较简单，毕竟只涉及到一个类，在设计模式中还是比较少见的。

使用单例模式可以减少内存开支，如果创建过程比较耗费资源，使用单例还可以优化性能。但是过度使用单例模式会导致系统的扩展性变差，而且也不利于测试。

一般来说单例模式有两种常见用法：
1. 全局只需要一个访问点
2. 对象需要消耗的资源过多

下面来看看常见的单例模式实现：

<!--more-->

## 懒汉模式
```java 
class SingleObject {
    private static SingleObject singleObject = new SingleObject();

    private SingleObject() {
    }

    public static SingleObject getSingleObject() {
        return singleObject;
    }
}
```

这是单例模式最简单的写法，如果对象占用资源比较小，这也是一种非常不错的写法，简单清晰。

## 饿汉模式
```java
class SingleObject {
    private static volatile SingleObject singleObject = null;

    private SingleObject() {
    }

    public static SingleObject getSingleObject() {

        if (singleObject == null) {
            synchronized (SingleObject.class) {
                if (singleObject == null) {
                    singleObject = new SingleObject();
                }
            }
        }

        return singleObject;
    }
}
```

饿汉模式中，只有第一次调用getSingleObject()时才会初始化对象。饿汉模式中有如下几点值得注意：
1. 变量类型是volatile
2. synchronized方法内，需要再执行一次singleObject == null的判断

volatile是为了解决内存可见性的问题，也就是一个线程修改了singleObject，另一个线程可以看到第一个线程的修改。关于第二个问题，如果两个线程都执行了`if (singleObject == null)`且都返回true，如果不在synchronized中再进行一次if判断，则会返回多个对象。

## 枚举模式
《Effective Java》中提出了另一种构造单例的方法，使用枚举类型，因为枚举默认是单例的。Joshua Bloch建议使用这种方法还有一个原因是上面的的方法可以用反射的机制得到多个实例对象。
```java 
public enum Singleton{
   INSTANCE;
   private int a ;
   public void doSomeThing(){}
}
```

## 多例模式
多例模式可以算是单例模式或工厂模式的变种：
```java 
import java.util.HashMap;
import java.util.Map;

/**
 * 扩展单例模式，控制实际产生实例数目为 3 个
 *
 * @author zhoumingyao
 */
public class ThreeSingleton {
    private final static String DEFAULT_PREKEY = "cache";//为后面使用的 key 定义一个前缀
    private final static int NUM_MAX = 3;
    private static Map<String, ThreeSingleton>
            map = new HashMap<String, ThreeSingleton>();//定义缓存实例的容器
    private static int number = 1;//定义初始化实例数目为 1

    private ThreeSingleton() {

    }

    public static synchronized ThreeSingleton getInstance() {
        //通过缓存理念及方式控制数量
        String key = DEFAULT_PREKEY + number;
        ThreeSingleton threeSingleton = map.get(key);
        if (threeSingleton == null) {
            threeSingleton = new ThreeSingleton();
            map.put(key, threeSingleton);
        }
        number++;//实例数目加 1
        if (number > NUM_MAX) {
            number = 1;
        }
        return threeSingleton;
    }
}
```

## 参考链接
1. 设计模式之禅(第二版)
2. [单例模式- 维基百科，自由的百科全书](https://zh.wikipedia.org/zh-cn/单例模式)
3. [深入浅出单实例SINGLETON设计模式](http://coolshell.cn/articles/265.html)
4. Effective Java(第二版)
5. [设计模式第一部分: 单例模式](https://www.ibm.com/developerworks/cn/java/j-lo-Singleton/)