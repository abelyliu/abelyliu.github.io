---
title: 自顶向下的并归排序
date: 2016-12-06 08:03:04
tags: Java
category: 算法
---
并归是将两个有序数组并归成一个更大的有序数组，而并归排序则是利用并归操作进行排序的方法。并归排序的思想是：
1. 将数组一分为二
2. 将两个数组排序
3. 合并两个数组

简单来说，就是把一个大数组排序分解为两个小数组排序，然后合并。你可能会考虑小数组还是需要排序，那我们可以将小数组再分解为两个更小的数组，递归下去，最终我们会得到大小为１的数组，这样这个数组就是有序的，接下来就需要处理两个有序数组的合并即可。
<!--more-->

## 合并数组
在并归排序中，合并操作是真正排序的部分，让我们先考虑一下如何合并两个有序的数组成为一个大数组。
两个有序数组合并的思路如下：
1. 取出数组一和数组二的第一项比较，将较小的放到已排序数组中；
2. 如果较小的在数组一，则取数组一的第二项和数组二的第一项比较，将较小的放到已排序数组中，反之同理；
3. 递归上述操作;
4. 如果有一个数组已经结束，则将另一个数组剩余项添加到已排序数组中。

```java
public static void merge(int start, int mid, int end, int[] array) {
    int m = start;
    int n = mid + 1;
    int[] temp = new int[end + 1];
    for (int i = start; i <= end; i++) {
        temp[i] = array[i];
    }
    for (int i = start; i <= end; i++) {
        if (m > mid) array[i] = temp[n++];
        else if (n > end) array[i] = temp[m++];
        else if (temp[m] > temp[n]) array[i] = temp[n++];
        else array[i] = temp[m++];
    }
}
```

上面代码中，for循环中分别代表四中情况:
1. 数组一已取完，将剩余数组二的值添加到已排序数组中；
2. 数组二已取完，将数组一剩余的值添加到已排序数组中；
3. 数组一的值大于数组二的值，取数组二的值到已排序数组中；
4. 数组一小于等于数组二，将数组一的值放到已排序数组中。

上述代码中要注意：
1. 额外数组的使用
2. 最后为什么用else，而非else if（tem[m]<=temp[n]）(会出错)

## 排序数组
上面也说了，并归排序是利用递归操作，将大数组分解，并归排序的核心代码如下：
```java
public static void sort(int start, int end, int[] array) {
   if (start >= end) return;
   sort(start, start + (end - start) / 2, array);
   sort(start + 1 + (end - start) / 2, end, array);
   merge(start, start + (end - start) / 2, end, array);
}
```

上述代码的注意点在于：
1. start和end能不能取，主要是保证sort中两个子sort可区间不能重复而且不能遗漏
2. 如何退出递归，也就是递归的边界条件
3. 数组不一定等分`start + (end - start) / 2`，我们也可除以３，４等等。

## 完整代码
```java
public class Test {

    public static void main(String[] args) {
        int[] array = {9, 8, 7, 6, 5, 4, 3, 2, 1};
        sort(0, 4, array);
        sort(5, 8, array);
        merge(0, 4, 8, array);
        for (int i : array) {
            System.out.print(i + " ");
        }
    }

    public static void sort(int start, int end, int[] array) {
        if (start >= end) return;
        sort(start, start + (end - start) / 2, array);
        sort(start + 1 + (end - start) / 2, end, array);
        merge(start, start + (end - start) / 2, end, array);
    }

    public static void merge(int start, int mid, int end, int[] array) {
        int m = start;
        int n = mid + 1;
        int[] temp = new int[end + 1];
        for (int i = start; i <= end; i++) {
            temp[i] = array[i];
        }
        for (int i = start; i <= end; i++) {
            if (m > mid) array[i] = temp[n++];
            else if (n > end) array[i] = temp[m++];
            else if (temp[m] > temp[n]) array[i] = temp[n++];
            else array[i] = temp[m++];
        }
    }
}
```
## 并归排序的局限性
- 并归排序的空间复杂度不是最优的
- 在实践中不一定遇到最坏的情况
- 除了比较，算法的其他操作(例如访问数组)也可很重要
- 不进行比较也能将某些数据排序
