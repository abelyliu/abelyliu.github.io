---
title: 二进制运算器
tags: 读书笔记,编码
---

## 加法

设计二进制加法器前，我们先看下二进制的加法。

|   +  |  0   |  1   |
| :---: | :---: | :---: |
|  0   | 00    |  01   |
|   1  |  01   |   10  |

我们知道，逻辑电路会将多个输入只会输出一个，所以我们这里将加法的结果分为，进位和加法位，上面的运算就变成下表。

进位

|   +  |  0   |  1   |
| :---: | :---: | :---: |
|  0   | 0    |  0   |
|   1  |  0   |   1  |

加法位

|   +  |  0   |  1   |
| :---: | :---: | :---: |
|  0   | 0    |  1   |
|   1  |  1   |   0  |

我们很明显发现加法位就是一个异或运算，下面是一个异或的简单实现。

![异或实现](https://github.com/abelyliu/pic/raw/master/pic/2.png)


而进位就比较简单，可以直接用与运算得到。

得到结果如下：

![半加器](https://github.com/abelyliu/pic/raw/master/pic/1.jpg)


这就是一个半加器，为什么叫半加器呢？因为这里只能处理输入，不能处理进位，我们知道实际运算中还要对进位进行处理。

如果要包含进位的处理，我们很容易想到在加一个半加器处理，设计的电路如下：

![全加器](https://github.com/abelyliu/pic/raw/master/pic/3.png)

上面将两个进位进行了或运算，这是基于两个进位不可能同时为1，这里可以简单思考一下。得到的结果就是一个全加器。

有了全加器之后我们要设计一个n位的二进制加法器，需要n个全加器即可，加和位和最后一个进位的值就是结果。


## 减法 

前面我们讲过计算机实现加法的原理，我们现在考虑如何实现计算机的减法？

举个例子，100-5=95，这里我们用到了借位的运算，计算机又如何实现借位呢？

计算机使用了一个巧妙的思想，避免了借位。实际上计算机没有直接实现减法，而是通过将减法转化为加法实现的。

我们想这样一个问题，13点再过24小时后是多少，结果显而易见，还是13点。

我们回到计算机编码中，假设我们只在8bit中做运算，而且被减数大于减数，8bit的范围为0~255，100-5 = 0110 0100 - 0000 0101 =  1 0000 0000 - 0000 0101 +0110 0100

上面等式的最后一步，我们引入了一个9bit的数值，之所以不会对结果影响，是因为我们限定了是8bit的运算，1111 1111+0000 0001=1 0000 0000=0000 0000，也就类似上面的模运算。

1 0000 0000 - 0000 0101 +0110 0100=1111 1111-0000 0101+0000 0001+0110 0100

1111 1111-0000 0101+0000 0001其实就是5的补码，100-5=100+(-5)，计算机之所以要用补码存储，很大一部分原因是这样直接可以用加法器直接处理减法。

在电路设计上，我们知道一个负数的补码，是其正数取反加一即可，取反用反相器即可，加一可以用第一个进位值直接设置。


