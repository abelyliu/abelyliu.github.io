---
title: 旋转数组的最小数字
date:  2017-2-28
tags: 算法
category: Java
---
原题如下：
> 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
> 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
> NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

## 遍历方案
题目读起来有些拗口，但是我们可以抛开题目中的逻辑，我们知道会输入一个有规则的数组，输出数组中的最小值。我们可以先抛开数组的规律，直接遍历求出其最小值。

<!--more-->

```java
public int minNumberInRotateArray(int [] array) {
	if(array==null) throw new IllegalArgumentException();
	int result = 0;
	if(array.length>0) result=array[0];
	for(int i =0;i<array.length;i++){
		if(result>array[i]) result=array[i];
	}
	return result;
}
```
## 排序方案
排序方案同样是不考虑数组的规律，也就是我们先对数组进行排序，然后直接取其最小值输出即可。此种方案无论从时间成本和空间成本都会比上一种方案高，具体的成本和排序算法有关。
```java
public int minNumberInRotateArray(int [] array) {
	if(array==null) throw new IllegalArgumentException();
	int result = 0;
	if(array.length>0) {
		Arrays.sort(array);
		result = array[0];
	}
	return result;
}
```
此处使用系统自带的排序函数只是想表明此种方案的可行性，当然我们可以手动使用其它的排序算法。

## 遍历方案的改进
上述的遍历方案并没有用到题目中的信息，我们可以利用这些信息改进一下。

我们知道输入是非递减排序的数组的一个旋转，首先看看非递减排序的数组。什么是非递减排序的数组?下面是三种类型：
1. [1,2,3,4,5]
2. [1,1,1,1,1]
3. [1,1,1,3,4]

如果将非递减数组旋转后会怎么样呢？
1. [3,4,5,1,2]
2. [1,1,1,1,1]
3. [1,3,4,1,1]

我们可以看到如果数组某两个之间出现了递减，则后一位则为最小值。
1. [5,1]中的1
2. [4,1]中的1

如果数组中没有出现递减则任意一个都可，代码如下：
```java
public int minNumberInRotateArray(int[] array) {
	if (array == null) throw new IllegalArgumentException();
	int result = 0;
	if (array.length > 0) {
		result = array[0];
		for (int i = 0; i < array.length-1; i++) {
			if(array[i+1]<array[i]) {
				result=array[i+1];
				break;
			}
		}
	}
	return result;
}
```
这样就可以减少循环次数，算法的时间复杂度和`若干个元素搬到数组的末尾`中若干个元素的数量与总元素之比有关。

## 二分查找
上面的方法简单的利用了非递减数组的性质，我们可以稍加改进，使用二分法跳跃式的查找最小值。

旋转后的数组实质上是两个非递减数组[A,B]，A和B都是非递减数组，且B中所有的元素都小于A中的元素。又因为A是非递减数组，所以A[0]是最小的值，也就是B中所有元素都小于A[0]。

如果我随意挑选数组中一个元素发现其大于A[0]，意味着这个元素不在B数组中，我需要在挑选一个在此元素右边的元素(往B靠拢)，如果元素小于A[0]，则意味这此元素在B中，我们需要元素左边挑选下一个元素(向A靠拢)。

这个就是算法的大致思路，我们得到了A和B的分割线就知道了B的最小值，也是数组的最小值，代码如下：
```java
public int minNumberInRotateArray(int[] array) {
	if (array == null) throw new IllegalArgumentException();
	int hi=array.length-1,lo=0;
	if (array.length > 0) {
		while (hi>lo){
			if(array[(hi+lo)/2]>=array[0]) lo=(hi+lo+1)/2;
			else if(array[(hi+lo)/2]<array[0]) hi=(hi+lo)/2;
		}
		return array[lo];
	}
	return 0;
}
```
和标准的二分查找一样，边界情况需要好好考虑。

## 修正二分查找
自己思考完后，查看了别人的解法，最理想的基本上都是使用二分查找。有个人叫小肥猴总结的挺好，三种情况：
1. 数组为空
2. 部分旋转，例如由（1,2,3,4,5）旋转为（3,4,5,1,2），此时只需要遍历数组，找到当前数比前面的数小的数即可
3. 完全旋转，例如由（1,2,3,4,5）旋转为（1,2,3,4,5），此时第一个数最小

我发现我没有考虑到第三种情况，也就是数组没有发生变化时，修改后代码如下：
```java
public int minNumberInRotateArray(int[] array) {
	if (array == null) throw new IllegalArgumentException();
	int hi=array.length-1,lo=0;
	if (array.length > 0) {
		while (hi>lo){
			if(array[(hi+lo)/2]>=array[0]) lo=(hi+lo+1)/2;
			else if(array[(hi+lo)/2]<array[0]) hi=(hi+lo)/2;
		}
		if(array[lo]>array[0]) return array[0];
		return array[lo];
	}
	return 0;
}
```
添加了一句`	if(array[lo]>array[0]) return array[0];`。
当然可以写一个更完美的二分法，像FINACK童鞋的二分：
```java
public int minNumberInRotateArray(int[] array) {
	int low = 0;
	int high = array.length - 1;
	while (low < high) {
		int mid = low + (high - low) / 2;
		if (array[mid] > array[high]) {
			low = mid + 1;
		} else if (array[mid] == array[high]) {
			high = high - 1;
		} else {
			high = mid;
		}
	}
	return array[low];
}
```
这个二分法看着就好一些。

