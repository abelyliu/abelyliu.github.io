<!DOCTYPE html>
<html lang="zh-cn">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="如何计算JAVA对象占用内存"/><meta name="keywords" content="memory, Abely" /><link rel="alternate" href="/default" title="Abely" ><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />
<link rel="canonical" href="http://abely.cn/2020/01/01/如何计算JAVA对象占用内存/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":false};
</script>

    <title>如何计算JAVA对象占用内存 - Abely</title>
  <meta name="generator" content="Hexo 5.4.0"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Abely</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">Home
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">Archives
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags
          </li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories
          </li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Abely</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            Home
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            Archives
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            Tags
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/categories/">
            Categories
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/about/">
            About
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">如何计算JAVA对象占用内存
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-01-01
        </span><span class="post-category">
            <a href="/categories/Java/">Java</a>
            </span>
        </div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-text">Java对象内存布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%8E%8B%E7%BC%A9"><span class="toc-text">指针压缩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E7%A4%BA%E4%BE%8B"><span class="toc-text">计算示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AE%A1%E7%AE%97%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8"><span class="toc-text">运行时计算内存占用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java-lang-instrument"><span class="toc-text">java.lang.instrument</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unsafe"><span class="toc-text">Unsafe</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RamUsageEstimator"><span class="toc-text">RamUsageEstimator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MemoryMeasurer"><span class="toc-text">MemoryMeasurer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E7%B1%BB%E5%BA%93"><span class="toc-text">其它类库</span></a></li></ol></li></ol>
    </div>
  </div><div class="post-content"><h2 id="Java对象内存布局"><a href="#Java对象内存布局" class="headerlink" title="Java对象内存布局"></a>Java对象内存布局</h2><p>首先我们需要了解下对象内存结构的基础知识，这里不过多展开(这里对象指非数组对象)</p>
<p><img src="https://abelytmp.oss-cn-hangzhou.aliyuncs.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/2020381581824087331-015a6de3-07ca-4400-99cd-bb97e241ed67.svg" alt="enter description here"></p>
<p>一个对象由四部分组成</p>
<ul>
<li>mark world 元数据，如对象的hash code，锁偏向等信息</li>
<li>klass ref 当前对象对应的class对象的引用，非JVM规范，这里是hotspot的优化</li>
<li>data 当前对象的成员变量等信息(代码等信息存放在方法区中)</li>
<li>padding 对齐到8字节的倍数(这里注意，也有对齐到16字节，和具体虚拟机有关，为了解释简洁，默认8字节)</li>
</ul>
<p>在32位的虚拟机中，引用大小都是32位，也就是4字节，对应的mark world也是4字节。即mark world 和klass ref都是4字节。</p>
<p>在64位虚拟机中，引用大小是64位，也就是8个字节，对应的mark world也是8字节。即mark world 和klass ref都是8字节。</p>
<span id="more"></span>

<h2 id="指针压缩"><a href="#指针压缩" class="headerlink" title="指针压缩"></a>指针压缩</h2><p>如果我们把计算机内存看作是一个一维数组，我们知道引用代表的是内存的地址，32位的范围为<code>[0000 0000,ffff ffff]</code>，64位范围为<code>[0000 0000 0000 0000,ffff ffff ffff ffff]</code>。</p>
<p>32位最大的内存为4G，当我们内存大于4G后我们则不得不修改JVM为64位虚拟机。</p>
<p>如果你仔细思考，你会发现一个问题，同样的程序在32位虚拟机需要的内存是小于64位虚拟机的(假设程序需要内存小于4g)，对于内存0这个位置，32位表示为<code>0000 0000</code> 4个字节，64位表示为<code>0000 0000 0000 0000</code> 8字节，我们知道java中有很多引用，这样会导致引用类型占用空间扩大一倍。</p>
<p>为了解决这个问题，就出现了指针压缩机制。</p>
<p>我们上面的图也说过，Java对象占用的内存一定是8的倍数，如果不是，则需要padding到8的倍数。</p>
<p><img src="https://abelytmp.oss-cn-hangzhou.aliyuncs.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/2020381579000372485-c0ff5f2a-84e8-44f1-b35b-e2dac3703503.svg" alt="enter description here"></p>
<p>上图对象1和对象2都是8个字节，对象3可能是8个字节或者8n个字节。我们观察可以发现所有非8n的字节地址是不可能成为对象的地址，所以我们可以人为规定0-&gt;0，8-&gt;1，16-&gt;2 … 8n-&gt;n。在实际寻址的时候再转化为对应实际地址，这样我们就可以用32位表示<code>4G*8=32G</code>内存大小的堆。换种方式理解，对象的内存地址十六进制表示，最后三位一定是0，这样我们就没有必要表示这三位，访问内存时通过将地址末尾增加3bit的0(就是乘8)，得到实际内存地址，这样就可以访问32G内存，这种思路在CPU分段，分页寻址时也有利用。</p>
<p>在JDK1.8中，指针压缩是默认开启的，即相当于<code>-XX:+UseCompressedOops</code>。所以在JDK1.8中，即使是64位虚拟机，只要没有修改启动参数，且内存小于32G，那么引用类型占用的大小就是32bit，即4个字节。</p>
<p>回到上面的内存布局，在64位压缩模式下，所有引用类型为4字节，即导致klass ref为4个字节而非8个字节。</p>
<h2 id="计算示例"><a href="#计算示例" class="headerlink" title="计算示例"></a>计算示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  List&lt;A&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10000</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">    list.add(<span class="keyword">new</span> A(i, <span class="keyword">new</span> B(i)));</span><br><span class="line">  &#125;</span><br><span class="line">  sleep(<span class="number">600000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  B b;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> a, B b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;</span><br><span class="line">    <span class="keyword">this</span>.b = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> b;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(<span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.b = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们来分析下A对象占用的内存大小，注意和list大小的区别。</p>
<p>按照我们上面的内存布局来计算<code>8(mark world)+4(klass ref)+4(int)+4(ref)+4(padding)=24B</code>。 </p>
<p>同理我们计算B的大小，<code>8(mark world)+4(klass ref)+4(padding)+8(long)=24B</code>。</p>
<p><img src="https://abelytmp.oss-cn-hangzhou.aliyuncs.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/2020381581748382902-213ecfdf-f8f7-4971-94ae-d46781e94b98.png" alt="enter description here"></p>
<p>上图中的单位是kB，注意和KB区分开，可以参考相应的维基百科<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8D%83%E5%AD%97%E8%8A%82">^1</a></p>
<p>上面计算的公式有两点值得注意</p>
<ol>
<li><p>A对象在计算大小时，并没有加上B对象的大小，只是增加了一个引用的大小(对象的shallow size)</p>
</li>
<li><p>在计算B对象大小时，我们先加padding，然后再加8，这个不是顺序写错了，而是内存布局就是这样</p>
</li>
</ol>
<p>如果你分析过JVM内存泄漏问题，那么应该看到过shallow size和retained size。shallow size代表的是A对象本身的大小，retained size代表A对象本身大小及递归其持有对象大小之和。这里A对象的retained size为24+24=48B。</p>
<p>对于第二个问题，简单解释就是padding不仅仅存在对象末尾，在klass ref和data之间，data内部之间，也是可能存在padding，这里不过多展开，如果想了解更多内存布局的知识，可以参考open jdk的jol工具及其示例<a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/code-tools/jol/">^2</a>。</p>
<h2 id="运行时计算内存占用"><a href="#运行时计算内存占用" class="headerlink" title="运行时计算内存占用"></a>运行时计算内存占用</h2><p>上面我们通过手动分析对象结构，从而计算占用大小，在实际开发中通过此种方式计算则比较困难。</p>
<ul>
<li>使用多少位虚拟机，是否开启指针压缩，对齐到8字节还是16字节等等需要事先知晓</li>
<li>对象层级结构复杂，持有其它对象比较常见</li>
<li>String这种动态大小对象很难事先评估</li>
</ul>
<h3 id="java-lang-instrument"><a href="#java-lang-instrument" class="headerlink" title="java.lang.instrument"></a>java.lang.instrument</h3><p>如果你观察过instrument的api，你会发现有个getObjectSize方法，但是这里也没说明是shallow size还是retained size。这里做个简单的实验</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//直接拿取Instrumentation比较麻烦，这里用ByteBuddy简化代码</span></span><br><span class="line">    Instrumentation install = ByteBuddyAgent.install();</span><br><span class="line">    System.out.println(install.getObjectSize(<span class="keyword">new</span> A(<span class="number">1</span>, <span class="keyword">new</span> B(<span class="number">1</span>))));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output 24</span></span><br></pre></td></tr></table></figure>

<p>可以看到，instrument返回的是shallow size。</p>
<h3 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h3><p>我们可以通过Unsafe拿到对象的内存地址，这样我们就可以通过分析内存地址，计算出对象的实际占用内存。可以参考<a target="_blank" rel="noopener" href="http://mishadoff.com/blog/java-magic-part-4-sun-dot-misc-dot-unsafe/%E4%BB%A3%E7%A0%81%EF%BC%8C%E4%B8%BB%E8%A6%81%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%8C%E6%80%9D%E8%B7%AF%E5%B0%B1%E6%98%AF%E5%8F%96data%E9%87%8C%E6%9C%80%E5%A4%A7%E7%9A%84%E5%86%85%E5%AD%98%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80%EF%BC%8C%E7%84%B6%E5%90%8E%E5%90%918%E7%9A%84%E5%80%8D%E6%95%B0%E5%8F%96%E6%95%B4%EF%BC%9A">http://mishadoff.com/blog/java-magic-part-4-sun-dot-misc-dot-unsafe/代码，主要代码如下，思路就是取data里最大的内存偏移地址，然后向8的倍数取整：</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sizeOf</span><span class="params">(Object o)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">  Field field = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">  field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">  Unsafe u = (Unsafe) field.get(<span class="keyword">null</span>);</span><br><span class="line">  HashSet&lt;Field&gt; fields = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  Class c = o.getClass();</span><br><span class="line">  <span class="keyword">while</span> (c != Object.class) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Field f : c.getDeclaredFields()) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((f.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">        fields.add(f);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c = c.getSuperclass();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get offset</span></span><br><span class="line">  <span class="keyword">long</span> maxSize = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (Field f : fields) &#123;</span><br><span class="line">    <span class="keyword">long</span> offset = u.objectFieldOffset(f);</span><br><span class="line">    <span class="keyword">if</span> (offset &gt; maxSize) &#123;</span><br><span class="line">      maxSize = offset;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ((maxSize / <span class="number">8</span>) + <span class="number">1</span>) * <span class="number">8</span>;   <span class="comment">// padding</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以稍微改造下此方法，虚拟机有可能对齐到16字节，所以我们可以动态计算需要对齐多少字节，<code>Integer.valueOf(System.getProperty(&quot;sun.arch.data.model&quot;))/8</code>;</p>
<p>我们使用此方法再次计算下A内存的大小</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">  System.out.println(sizeOf(<span class="keyword">new</span> A(<span class="number">1</span>, <span class="keyword">new</span> B(<span class="number">1</span>))));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output 24</span></span><br></pre></td></tr></table></figure>

<p>我们同样计算出了对象的shallow size。</p>
<p>计算的思路主要就上面两种，很多计算内存占用内存分析的工具思路也是上面，网上还有使用Runtime.getRuntime().totalMemory()和Runtime.getRuntime().freeMemory()计算前后内存查，算近似值，这里只适合较大对象，且还需要确保GC不会影响。接下来我们看下类库中的实现：</p>
<h3 id="RamUsageEstimator"><a href="#RamUsageEstimator" class="headerlink" title="RamUsageEstimator"></a>RamUsageEstimator</h3><p>RamUsageEstimator是 lucene-core 里面的一个工具类，他提供了一个计算对象shallow size的方法，基本原理就是通过反射拿到所有字段，计算私有类型和引用类型占用大小，并对齐字节(实质上就是unsafe方式)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> l = RamUsageEstimator.shallowSizeOf(<span class="keyword">new</span> A(<span class="number">1</span>, <span class="keyword">new</span> B(<span class="number">1</span>)));</span><br><span class="line">    System.out.println(l);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output 24</span></span><br></pre></td></tr></table></figure>



<h3 id="MemoryMeasurer"><a href="#MemoryMeasurer" class="headerlink" title="MemoryMeasurer"></a>MemoryMeasurer</h3><p><a target="_blank" rel="noopener" href="https://github.com/DimitrisAndreou/memory-measurer%EF%BC%8C%E8%BF%99%E4%B8%AA%E9%A1%B9%E7%9B%AE%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%80%E4%B8%AA%E6%B5%8B%E9%87%8F%E5%AF%B9%E8%B1%A1%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%96%B9%E6%B3%95">https://github.com/DimitrisAndreou/memory-measurer，这个项目提供了一个测量对象大小的方法</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> memory = MemoryMeasurer.measureBytes(<span class="keyword">new</span> A(<span class="number">1</span>, <span class="keyword">new</span> B(<span class="number">1</span>)));</span><br><span class="line">    System.out.println(memory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output 48</span></span><br></pre></td></tr></table></figure>

<p>可以看到，这个工具是直接计算对象的retained size。这个项目因为是agent方式，所以也没有放到maven仓库中，可以拉下来本地编译<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007183623">^3</a>。</p>
<p>看到是使用agent方式，应该就能猜出来本质上和instrument方法是一样的，使用了反射遍历对象去计算实际大小。 </p>
<h3 id="其它类库"><a href="#其它类库" class="headerlink" title="其它类库"></a>其它类库</h3><ol>
<li><p><a target="_blank" rel="noopener" href="https://github.com/fracpete/sizeofag">https://github.com/fracpete/sizeofag</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/apache/wicket/tree/master/wicket-objectsizeof-agent">https://github.com/apache/wicket/tree/master/wicket-objectsizeof-agent</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/arturmkrtchyan/sizeof4j">https://github.com/arturmkrtchyan/sizeof4j</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/jbellis/jamm/">https://github.com/jbellis/jamm/</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/phatak-dev/java-sizeof">https://github.com/phatak-dev/java-sizeof</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/ehcache/sizeof">https://github.com/ehcache/sizeof</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/com.carrotsearch/java-sizeof">https://mvnrepository.com/artifact/com.carrotsearch/java-sizeof</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/code-tools/jol/">https://openjdk.java.net/projects/code-tools/jol/</a></p>
</li>
</ol>
<p>前4个和上面的两个例子区别不大。</p>
<p>第5个也类似，不过返回的是retained size，使用Scala写成，按项目文档上描述是从spark项目抽取出来。</p>
<p>第6个实现方式也是通过instrument，它和MemoryMeasurer不同点在于不需要增加agent启动参数，也不是通过我们例子中的ByteBuddy方式attach，而是调用java attach api，但是和ByteBuddy一样，只能运行在JDK的环境中，这里额外说下<a target="_blank" rel="noopener" href="https://github.com/electronicarts/ea-agent-loader">EA Agent Loader</a>这个项目可以在jre环境attach，不过不能是本地类库，而且已经停更了。另一个重要的区别在于这个可以计算shallow size也可以计算retained size。</p>
<p>第7个没有找到对应的主页，这个项目使用unsafe，同时支持shallow size和retained size。</p>
<p>如果你也需要使用运行时计算内存，很明显地7类库是比较方便的。因为没有主页，这里提供一个使用示例，具体使用方法可以阅读RamUsageEstimator的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">t1</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(RamUsageEstimator.sizeOf(<span class="keyword">new</span> A(<span class="number">1</span>, <span class="keyword">new</span> B(<span class="number">1</span>))));</span><br><span class="line">    System.out.println(RamUsageEstimator.shallowSizeOf(<span class="keyword">new</span> A(<span class="number">1</span>, <span class="keyword">new</span> B(<span class="number">1</span>))));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output 48 24</span></span><br></pre></td></tr></table></figure>

<p>第8个类库，这个前文已经提过了，很推荐大家把官方的例子运行一遍，涉及到很多内存布局的知识，计算shallow size和retained size也只是其中的一个小功能，这个类库是你理解内存布局的不二之选。</p>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>Author: </span>
      <a href="http://abely.cn">Abely Liu</a>
    </p>
    <p class="copyright-item">
      <span>Link: </span>
      <a href="http://abely.cn/2020/01/01/%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97JAVA%E5%AF%B9%E8%B1%A1%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98/">http://abely.cn/2020/01/01/%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97JAVA%E5%AF%B9%E8%B1%A1%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98/</a>
    </p>
    <p class="copyright-item">
      <span>License: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/memory/">memory</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2021/04/07/JVM%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">JVM调优案例</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
        <a target="_blank" rel="noopener" href="https://github.com/ahonn" class="iconfont icon-github" title="github"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2015 - 2021<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Abely Liu</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
