---
title: 斐波那契数列的求解
date:  2017-2-27
tags: 算法
category: Java
---
今天上班没啥事，于是又上牛客上刷了一题，也就是都知道的斐波那契数列的求解。

> 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。 n<=39

## 使用递归
第一反应是使用递归，代码如下：
```java
 public int Fibonacci(int n) {
	if (n <= 0) return 0;
	if (n == 1 || n == 2) return 1;
	return Fibonacci(n - 1) + Fibonacci(n - 2);
}
```
代码逻辑是没有什么问题，但是此方法效率非常低下。在本人的电脑上计算第五十位需要四十多秒，而且结果已经溢出(第47位开始溢出)。

## 添加缓存
考虑到计算`Fibonacci(n - 1)`和`Fibonacci(n - 2)`之间会有重复的计算，我们可以添加缓存，缓存计算的值。
```java
    int[] temp = new int[1000];
    public int Fibonacci(int n) {
        if(n<=0) return 0;
        if(n==1||n==2) return 1;
        if(temp[n]==0) temp[n]=Fibonacci(n-1)+Fibonacci(n-2);
        else return temp[n];
        return Fibonacci(n-1)+Fibonacci(n-2);
    }
```
此时在计算的速度有了明显的提升，至于数值溢出的问题已经无法在牛客上测试了，其方法签名固定为int。

## 修改方法签名
修复数值溢出的问题，一开始我想到了用long来替代int类型，但是发现long在第93发生溢出，于是切换为BigInteger对象。
```java
BigInteger[] temp = new BigInteger[10000];
public BigInteger Fibonacci(int n) {
	if(n<=0) return new BigInteger("0");
	if(n==1||n==2) return new BigInteger("1");
	if(temp[n]==null) temp[n]=Fibonacci(n-1).add(Fibonacci(n-2));
	else return temp[n];
	return Fibonacci(n-1).add(Fibonacci(n-2));
}
```
现在数值不会溢出了，但是会出现另一个情况，栈溢出` java.lang.StackOverflowError`。在本人电脑上大概计算第8000左右位时会出现栈溢出。

## 外加循环
在Java中貌似没有尾递归优化，所以要想解决栈溢出的核心思想是解决递归的深度。我们可以修改算法:
1. 改成使用循环实现方法
2. 循环调用方法

我们看看如何使用第二种方法，在现有代码基础上进行修改。
```java
BigInteger[] temp = new BigInteger[100_0000];
public static void main(String[] args) {
	Test test = new Test();
	long startTime = System.currentTimeMillis();
	for(int i=4000;i<19_0000;i=i+1000){
		test.Fibonacci(i);
	}
	System.out.println(test.Fibonacci(18_9999));
	System.out.println(System.currentTimeMillis()-startTime);
}

public BigInteger Fibonacci(int n) {
	if(n<=0) return new BigInteger("0");
	if(n==1||n==2) return new BigInteger("1");
	if(temp[n]==null) temp[n]=Fibonacci(n-1).add(Fibonacci(n-2));
	else return temp[n];
	return temp[n];
}
```
上述代码的核心在与
```java
for(int i=4000;i<19_0000;i=i+1000){
	test.Fibonacci(i);
}
```
i的初始值不要让栈溢出即可，i每次加的数值也不能使栈溢出。

在本人电脑环境下，计算十九万位时，需要两秒多。但此种方法的问题在于计算第二十万位左右时会发生堆溢出`Exception in thread "main" java.lang.OutOfMemoryError: Java heap space`。

## 减少缓存
上面之所以出现堆溢出，是因为缓存了过多的数据，我们理论上只需要前两次的计算数据。
```java
public BigInteger Fibonacci(int n) {
	if(n<=0) return new BigInteger("0");
	if(n==1||n==2) return new BigInteger("1");
	if(temp[n]==null){
		temp[n]=Fibonacci(n-1).add(Fibonacci(n-2));
		temp[n-2]=null;
	}
	else return temp[n];
	return temp[n];
}
```
上面添加了`temp[n-2]=null;`这句话，这样只会缓存两个数据，减少了内存占有量。此种方法计算第100万位时大约需要16秒左右。当然这个代码还可以优化，比如temp并不需要一个数组，只需要两个数值即可，但影响不是特别大，下面是使用内循环类似的方法：
```java
BigInteger temp1 = new BigInteger("1");
BigInteger temp2 = new BigInteger("1");
public BigInteger Fibonacci(int n) {
	if (n <= 0) return new BigInteger("0");
	if (n == 1 || n == 2) return new BigInteger("1");
	BigInteger result = new BigInteger("0");
	for (int i = 3; i <= n; i++) {
		result = temp1.add(temp2);
		temp1 = temp2;
		temp2 = result;
	}
	return result;
}
```
这两种方法的计算速度是差不多的，算法时间复杂度为O(n)，空间为2个额外空间。

上网查看了一下别人的解题思路，没有看到小于n的时间复杂度，思路都是类似，递归的思路一般而言应该是一种动态规划的思路。动态规划就是通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。


## 参考链接
1. [动态规划](https://zh.wikipedia.org/zh-cn/动态规划)