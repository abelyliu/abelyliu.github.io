---
title: 正则基础介绍
---

在介绍正则表达式之前，我们先来了解下正则表达式能做什么。

> 正则表达式只能匹配字符串

从匹配字符串的功能中我们可以扩展出一些其他的功能，如：
- 验证
- 查找
- 替换(删除)

这里我们要注意正则的核心是匹配字符串，所以当使用正则匹配不包含"xx"的字符串时逻辑就显得比较繁琐。

我们要匹配abc，最直白的想法输入abc，这样很容易理解也很容易实现，但是可扩展性极差，极其依赖输入文本，在不知道输入文本的情况下根本无法写出匹配表达式，而且对于一些模式匹配就无能为力了，比如匹配一个回环字符(aba,dfd)。

想要理解正则表达式只要理解好那些元字符用法即可。

元字符是具有特殊含义的字符，并不会直接匹配对应的字符。比如正则里的`a`可以匹配字符串"a"，但正则里的`\`就不会直接匹配字符串"\\"，因为`\`是一个元字符，功能就像java里的`\`，用作转义，正则里的`\\`会匹配字符串"\\"。

<!--more-->

## 元字符

`.`可以匹配任意单个字符，不可匹配空字符
`\`转义元字符，`\.`就可以匹配`.`

## 或
`|`或 `abc|bcd`可以匹配"abc"或则"bcd"，不能匹配"abccd"或"abbcd"，可以理解`|`的优先级比较低
`[]`可选集合 `ab[cd]e`可以匹配"abce"或"abde"，等价于`ab(c|d)e`
`[]`里面有许多元字符讲不在是元字符如`|`，`ab[c|d]e`可以匹配"ab|e"。也有一些其他的元字符会改变其含义如`^`，`ab[^cd]e`可以匹配"abxe",`x`只要不是`c`也不是`d`即可。`[]`也会将非元字符变成元字符如`-`，`ab[h-o]e`可以匹配"abhe"，"abme"，只要第三个字符在`h`和`o`之间即可。`[]`里面哪些会有特殊含义哪些没有，就需要多写几次正则，自己测试下即可。


### 位置匹配
`^` 字符串开始
`$` 字符串结尾

![](/images/75.png)

上面的字符串是"Are you ok?"中1代表`^`，12代表`$`，这个匹配的不是字符串，而是字符串中的一个位置。

## 反向引用
`\n` n是一个具体的数字，代表前面匹配的一个子串
`(a)(b)\1\2`(java里是`(a)(b)\\1\\2`，`\`是元字符，所以需要写成`\\`)，\1代表a，\2代表b，最后匹配的结果是abab。
有种简单的理解办法是\1代表第一个括号内匹配的东西，\2代表第二个括号内匹配的东西，\3代表第三个括号内匹配的东西。

`((a))(b)\1\2`又会匹配什么呢？abaa
`((a))(\1)(b)\3`又会匹配什么呢？aaba


## 量词匹配
`*` 0个或0个以上
`+` 1个或者1个以上
`?` 0个或者1个
`{n}` n个
`{n,}` n个或者n个以上
`{n,m}` n和m之间
`?` 在上述字符后面时代表非贪婪匹配

上面的所有的量词都是修饰符，也就意味着这些字符的前面一定要有其他的字符。下面的正则表达式就是错误的：
- `*`
- `+abc`

这些量词前面一定要有字符去被修饰，`.*`就是一个正确的正则表达式，可以匹配任意字符。`.`可以匹配任意单个字符，`*`修饰的意思可以有0个或者任意多个。`abc{2,3}`可以匹配"abcc"或"abccc"。

上面的量词前几个都比较好理解，如何理解最后一个的？
我们先看下面这个例子
"abcccc".replaceAll("abc{2,3}", ",")输出是什么？
这里正则可以替换"abcc"为","或"abccc"替换为","，你去运行程序发现输出为",c"，这里牵扯到正则的运行逻辑，正则表达式默认匹配更多的字符串，所以在有选择的情况下会将"abccc"替换为,。那我们如何实现优先替换"abcc"，在没有无法替换的情况才替换abccc。这里就引入了`?`
"abcccc".replaceAll("abc{2,3}?", ",")  输出",cc"

下面的输出：
"abcccc".replaceAll("ab.*?", ",") ",cccc"
"abcccc".replaceAll("ab??", ",") ",bcccc"

## 环视
一开始我们讨论过位置匹配的元字符(`$`,`^`)，但有时候我们需要自定义一个位置进行匹配。这个时候我们就需要引入环视机制。

为什么我们需要匹配位置呢？我们可以考虑上面那个"Are you ok"的字符串，如何匹配you中的o，而不匹配ok中的o。

前面我们说过，正则只能匹配，我们就需要找到这两个o之间的差别。这两个o有什么差别呢？

就是所处的位置不同，you中的o前面是y后面是u，ok中o则不具有这个特征。所以我们需要匹配这样一个字符串，'xoy'，x和y代表一个位置，而不是具体的字符，x代表的是y和o之间的位置，y代表o和u之间的位置。

如果我们能写出这样的表达式，就可以匹配you中的o，不匹配ok中的o。所以我们需要了解正则中匹配位置的写法，一般我们常用的不包含xx的字符串也可以用环视的功能实现。

环视有四种逻辑：
1. 顺序肯定环视（又名：零宽度正预测先行断言）：(?=Expression)
2. 顺序否定环视（又名：零宽度负预测先行断言）：(?!Expression)
3. 逆序肯定环视（又名：零宽度正回顾后发断言）：(?<=Expression)
4. 逆序否定环视（又名：零宽度负回顾后发断言）：(?<!Expression)


我们回到"Are you ok的例子

![](/images/75.png)

下面的输出结果都是"Are y,u ok?"
顺序肯定环视两种写法
"Are you ok?".replaceAll("(?=ou)o", ",")   //`(?=ou)`匹配6号位置
"Are you ok?".replaceAll("o(?=u)", ",")    //`(?=u)`匹配7号位置

顺序否定环视两种写法
"Are you ok?".replaceAll("(?!ok)o", ",")  //`(?!ok)`匹配不是9号位置外所有位置
"Are you ok?".replaceAll("o(?!k)", ",")   //`(?!k)`匹配不是10号位置外的所有位置

逆序肯定环视两种写法
"Are you ok?".replaceAll("(?<=y)o", ",")  //`(?<=y)`匹配6号位置
"Are you ok?".replaceAll("o(?<=yo)", ",")  //`(?<=yo)`匹配7号位置

逆序否定环视两种写法
"Are you ok?".replaceAll("(?<! )o", ",") //`(?<! )`匹配9号位置，!后有个空格
"Are you ok?".replaceAll("o(?<! o)", ",") //`o(?<! o)`匹配10号位置，!后有个空格

上面只要理解顺序肯定，顺序否定就是所有不是顺序肯定的位置。理解逆序肯定，逆序否定就是所有不是逆序肯定的位置。还有一个值得注意的是同一个位置顺序和逆序是如何匹配的。

这里可以考虑如些写一个不包含loginTime的字符串的正则表达式。

## NFA和DFA
NFA和DFA是正则表达式实现的两种方式，这里简单介绍下是因为有时候可能会对你造成困惑。
输入 "nfa not" 正则为"nfa|nfa not"，匹配的结果是什么？

![](/images/76.png)

![](/images/77.png)


`to(nite|knight|night)` 匹配字符串   "…tonight…"

NFA:to匹配后，判断night是否符合nite，在night的g字符时发现无法匹配，回退到to的o处，用knight进行匹配，在k的位置发现无法匹配，在回退到to的o处，用night匹配，成功
DFA：to匹配后,发现n符合nite和night，knight被抛弃，i都符合继续，g发现nite不符合，抛弃，h和t night都符合返回。

DFA，每个字符再一次判断中只会访问一次，NFA则不然，每次需要回退到上次匹配的地方重新尝试。所以NFA得引擎和写法关系很大，DFA则和表达式的写法关系不大。

DFA的优势在于匹配速度快，和表达无关，NFA的优势在于功能相对强大，如支持反向引用，DFA引擎就不支持。

## 其他

正则表达式还有很多知识点没有涉及到，因为下面的这些东西我本人也没有在实践中需要，这里也不打算介绍，感兴趣可以自行查阅资料。
- 正则表达式优化
- 模式修饰符
- 固化分组


