---
title: 栈的压入弹出序列
date:  2017-3-2
tags: 算法
category: Java
---

> 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）

看到这个题目思考了一下，一开始想找出所有可能的出栈序列，然后比较即可。随后我发现这种方案不太现实，出栈序列应该是指数级别的，这样就把问题复杂化了。

然后第二种想法就是模拟人解决这个问题的思路，假设输入为`1,2,3,4,5`，输出为`4,5,3,2,1`：
1. 输出序列第一个为4，所以1,2,3,4都要入栈，然后4出栈，此时栈为1,2,3
2. 输出序列第二个为5，如果继续出栈应该为3，所以需要入栈一直到5，然后5出栈，此时栈为1,2,3
3. 输出序列第三个为3，如果继续出栈为3，所以执行出栈(此时也无法入栈)，此时栈为1,2
4. 输出序列第四个为2，如果继续出栈为2，所以继续出栈
5. 输出序列第四个为1，如果继续出栈为1，所以继续出栈
6. 发现所有的输入都出栈了且匹配，所以为正确的出栈序列

<!--more-->

抽象出上面的逻辑：
1. 入栈到出栈数然后出栈
2. 如果此时栈为空，跳到第1步
3. 如果栈不为空且栈顶和出栈数相等，则出栈，然后继续执行本步骤，否则执行步骤1

```java
public boolean IsPopOrder(int[] pushA, int[] popA) {
	Stack<Integer> stack = new Stack<>();
	int j = 0;
	for (int aPushA : pushA) {
		if (aPushA != popA[j]) {
			stack.push(aPushA);
		} else {
			while (true) {
				if(stack.empty()){j++;break;}
				int temp = stack.pop();
				if (popA[++j] != temp) {
					stack.push(temp);
					break;
				}else if(stack.empty()){
					j++;
					break;
				}
			}
		}
	}
	return j == popA.length ;
}
```
这是我一开始的版本，代码很丑陋。上面代码复杂的原因在于直接弹出栈顶元素的，如果不符合还需要push回去，查看了一下api发现有个peek方法可以直接取出栈顶元素不会实际弹出，修改后如下：
```java
public boolean IsPopOrder(int[] pushA, int[] popA) {
	Stack<Integer> stack = new Stack<>();
	int j = 0;
	for (int aPushA : pushA) {
		stack.push(aPushA);
		while (j < popA.length && stack.peek() == popA[j]) {
			stack.pop();
			j++;
		}
	}
	return j == popA.length;
}
```