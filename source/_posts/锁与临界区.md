---
title: 锁与临界区
date:  2017-2-21
tags: 并发
category: Java
---
临界区用来表示一种公共资源或共享数据，可以被多个线程使用。但每一次，只能有一个线程使用它，一旦临界区被占用，其它线程想使用这个资源，就必须等待。

临界区的问题，基本上就是并发程序要处理的最核心问题，一不留神就会写出问题代码。一般来说，关于资源的竞争会出现三种情况：死锁，活锁和饥饿。

### 死锁
如果线程A和线程B都需要资源X和Y，线程A得到了X，线程B得到了Y，那么线程A会一直等待Y，线程B会一直等待X。如果不加干预，这两个线程将会一直停止在这里。

如果系统中只有一个进程，当然不会产生死锁。如果每个进程仅需求一种系统资源，也不会产生死锁。不过这只是理想状态，在现实中是可遇不可求的。

我们先看看死锁产生的必要条件：
1. 互斥条件：一个资源每次只能被一个进程使用。
2. 占有且等待：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不可强行占有:进程已获得的资源，在末使用完之前，不能强行剥夺。
4.  循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

<!--more-->
直到了死锁的必要条件，我们可以破坏任意一个条件，使其无法形成死锁。简单来说分为两种，一种是预防进程间形成死锁，二是形成死锁之后解除死锁。

我在这里也没有区分线程和进程，只要使临界区中的竞争，无论是线程间的还是进程间的，区别不是特别大。线程主要是在Java虚拟机环境下，而进程竞争的讨论往往是操作系统层面上的。

### 活锁
关于活锁，网上解释的比较少，基本都是如下解释：

> 举个很简单的例子，两个人相向过独木桥，他们同时向一边谦让，这样两个人都过不去，然后二者同时又移到另一边，这样两个人又过不去了。如果不受其他因素干扰，两个人一直同步在移动，但外界看来两个人都没有前进，这就是活锁。
> 
> 活锁会导致CPU耗尽的，解决办法是引入随机变量、增加重试次数等。
> 
> 所以活锁也是程序设计上可能存在的问题，导致进程都没办法运行下去了，还耗CPU

理解起来虽然没有什么问题，但是一直无法找到具体的例子或代码，有点遗憾。


### 饥饿
饥饿是指如果线程T1占用了资源R，线程T2又请求封锁R，于是T2等待。T3也请求资源R，当T1释放了R上的封锁后，系统首先批准了T3的请求，T2仍然等待。然后T4又请求封锁R，当T3释放了R上的封锁之后，系统又批准了T4的请求......，T2可能永远等待。

简单来说，线程因为种种原因一直无法得到资源，导致线程一直无法执行下去。最容易理解的例子就是：如果某个线程的优先级非常低，那么这个线程很有可能一直无法执行，这就是所谓的饥饿。从某种程度上说，活锁也是一种饥饿。


## 参考链接
1. Java高并发程序设计
2. [死锁 - 维基百科](https://zh.wikipedia.org/zh-cn/死锁)
3. [死锁的四个必要条件](http://blog.csdn.net/rabbit_in_android/article/details/50530960)
4. [活锁](https://www.kancloud.cn/kancloud/understanding-linux-processes/52176)
